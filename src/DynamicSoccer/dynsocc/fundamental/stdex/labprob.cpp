#include <stdlib.h>
#include <stdio.h>
/*
struct Event 
{
    int parameter;
};

typedef EventDescription int;
typedef RandomVariable int;
typedef PFunction int; 
typedef Mapping int;
typedef Anything int;

typedef Space int;
typedef Set int;

#define Typeof(a) 1
#define Motivation(a) 1

struct ASet 
{
public: 
    int* every_values;
    int nval;

    int nVal;        
};

#define Identical(o, a, b)  1
#define Equal(a,b) 1 
#define FindAFormula(a) 1
#define FindExactValue(a) 1

int Ex3_1() 
{
    // Definition of Mapping 
    RandomVariable r1;

    // Is Mapping? 
    // FLow? 
    Anything observation1; 
    Motivation(observation1);

    Motivation(observation1);
    EventDescription e1; // x>=1 


    // Dice definition 
    RandomVariable dice1;
    RandomVariable dice2;

    dice1.Distribution = { 0.5, 0.5 };
    dice2.Distribution = dice1.Distribution;

    // 
    // Following: Theory of 
    // 
    // Invent new formula.
    Transformation? 

    // Calculating P of an Event? 

    typedef AvailableOutput int;
    AvailableOutput av1;
    AvailableOutput av2;




    // P(Event=)=? RandomVariable
    // Mapping between (real-world) & ()

    int nSumDot = 0;
    // Two (identical) dices 
    //  P(count=6 | count % 2 = 0) = ?    
    // 
    Event e1;
    Event e2;

    // 
    // Describle exactly 
    // Automatically resolving 
    // 

    //
    // Describle 
    //
    // Definition of a dice? 
    // Definition 
    // Dice: 1 process mà có 6 kết quả.
    // 
    // System 
    //      Dice. 
    //

    typedef Process int;
    typedef RandomVariable int;

    Process a;
    Process b;
    WholeEco p1;
    WholeEco p2;

    a.depends(b);
    b.depends(c);

    Event twoDice = 0;

    RandomVariable dice1;
    RandomVariable dice2;

    Event evenSum((dice1 + dice2) % 2 == 0);
    Event count6((dice1+dice2)==6);

    a.independent(b);
    p1.run();
    p1.Probability(count6, evenSum);
    double p = p1.Probability(count6, evenSum);

    a.independent(b);
    Completed(Equal(a,b));
    // Number Only 
    RandomVariable rd1;
    RandomVariable rd2;
    // 

    // Teach machine to estimate probability:
    //      + Able to define Event (Dice)
    //      + Able to define combined Event
    //      + Able to define SampleSpace
    #define CombineModel(m1,m2) 1
    #define Model(sample_space, p_function) 1
    #define DefineRandomVariable(model) 1
    typedef int SampleSpace;
    typedef int Model;
    SampleSpace s1;
    SampleSpace s2;

    Model dice1;
    Model dice2;

    #define Set 1
    #define EverythingIsSet 1 

    #define Number(a)  1 
    #define Range(a,b) 1
    #define Shape(a) 1
    #define RangeShape(a) 1
    #define ValueDescription 1

    ValueDescription(2)
    ValueDescription(3)

    Range(a,b)
    Range(a,b)

    if (Range(a,b))
    {
        Range(a,b)
    }

    // Area? 

    // Finding Probability using Model 
    // Probability = 
    P(EventA)=Weight(A)/Weight(Whole);  
    Anything EventA = subset(Whole); // SubSet(Whole)
    Anything EventB subset(Whole); // Subset (Whole)

    subset(Whole); // Subset(Whole)


    // Problem: calculate Probability 
    //      * Output1: Exactly number
    //      * Output2: Formula
    // Describle

    // Value & Types 
    // Value & Types 

    // Discrete (Number)
    // Area 
    // Finding Truth? 
    EventA: { Shape }
    InfinitiveShape? 
    FiniteShape? 
    Infinitive / Infinitive = ? 

    typedef int Anything; 
    Anything _a;
    Area(_a) / Weight(_a); 

    typedef int Anything;
    Area(_a) / Weight(_a);

    Variables v1, v2, v3;
    Event a; 
    Event a(a condition);

    IsValueOf(S);
    EveryValue(S);
    ForAny;
   Variables v1, v2, v3;

   #define NOTHING 0


   // Dice Definition
   SampleSpace = {1,2,3,4,5,6};
    // Listing every value 
    // Formula description 
    // Routine description 
   P_function[i]=1/6; // Every i? 
   P_function.MapFrom = SampleSpace;
   P_Function.MapTo = Real;
   P_Function.Formula = 1/6; // Every i?

   AI.Run(P_Function(6));
   P_Function(6);
   AI.Run(P_Function(7));
}

int Equals()
{
    Known();
    FindExactValue(a);
}
*/